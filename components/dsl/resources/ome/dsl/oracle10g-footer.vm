--
-- Copyright 2011 Glencoe Software, Inc. All rights reserved.
-- Use is subject to license terms supplied in LICENSE.txt
--

--
-- This file was generated by dsl/resources/ome/dsl/oracle10g-footer.vm
--

--
-- Triggers
--
-- Not necessary in Oracle since constraints can be initially deferred.
-- but indexes on all FK columns are needed for performance reasons.

--
-- Indexes
--
#foreach($type in $types)
#if(!$type.superclass && !$type.global)
#set( $tblName = $type.tableName() )
#set( $ownerIdx = $type.indexName("owner") )
#set( $groupIdx = $type.indexName("group") )
  CREATE INDEX $ownerIdx ON $tblName(owner_id);
  CREATE INDEX $groupIdx ON $tblName(group_id);
#end
#foreach($prop in $type.classProperties)
#if( $prop.foreignKey && ! $prop.name.equals("details")  && ! $prop.one2Many )
#set( $tbl_name = $prop.actualType.tableName() )
#set( $col_name = $prop.actualType.columnName($prop, '"') )
  CREATE INDEX $type.indexName($prop) ON $tbl_name($col_name);
#end
#end
#end

--
-- a function for showing our permissions
-- select id, ome_perms(permissions) FROM sometable...
--

CREATE OR REPLACE FUNCTION ome_perms(p NUMBER)
RETURN VARCHAR
IS
       ur CHAR(1) DEFAULT '-';
       uw CHAR(1) DEFAULT '-';
       gr CHAR(1) DEFAULT '-';
       gw CHAR(1) DEFAULT '-';
       wr CHAR(1) DEFAULT '-';
       ww CHAR(1) DEFAULT '-';
   BEGIN
       -- shift 8
       SELECT CASE
                 WHEN BITAND(LPAD(conversion_api.to_bin(p),    64, 0),
                             LPAD(conversion_api.to_bin(1024), 64, 0)) = LPAD(conversion_api.to_bin(1024), 64, 0)
                 THEN 'r'
                 ELSE '-'
              END
         INTO ur
         FROM dual;
       SELECT CASE
                 WHEN BITAND(LPAD(conversion_api.to_bin(p),   64, 0),
                             LPAD(conversion_api.to_bin(512), 64, 0)) = LPAD(conversion_api.to_bin(512), 64, 0)
                 THEN 'w'
                 ELSE '-'
              END
         INTO uw
         FROM dual;
       -- shift 4
       SELECT CASE
                 WHEN BITAND(LPAD(conversion_api.to_bin(p),  64, 0),
                             LPAD(conversion_api.to_bin(64), 64, 0)) = LPAD(conversion_api.to_bin(64), 64, 0)
                 THEN 'r'
                 ELSE '-'
              END
         INTO gr
         FROM dual;
       SELECT CASE
                 WHEN BITAND(LPAD(conversion_api.to_bin(p),  64, 0),
                             LPAD(conversion_api.to_bin(32), 64, 0)) = LPAD(conversion_api.to_bin(32), 64, 0)
                 THEN 'w'
                 ELSE '-'
              END
         INTO gw
         FROM dual;
       -- shift 0
       SELECT CASE
                 WHEN BITAND(LPAD(conversion_api.to_bin(p),  64, 0),
                             LPAD(conversion_api.to_bin(4),  64, 0)) = LPAD(conversion_api.to_bin(4), 64, 0)
                 THEN 'r'
                 ELSE '-'
              END
         INTO wr
         FROM dual;
       SELECT CASE
                 WHEN BITAND(LPAD(conversion_api.to_bin(p),  64, 0),
                             LPAD(conversion_api.to_bin(2),  64, 0)) = LPAD(conversion_api.to_bin(2), 64, 0)
                 THEN 'w'
                 ELSE '-'
              END
         INTO ww
         FROM dual;

       RETURN ur||uw||gr||gw||wr||ww;
END ome_perms;
/
--
--
-- #1176 : create our own nextval() functionality for more consistent
-- sequence operation in hibernate. This functionality was updated for
-- OMERO 4.2 (#2508) in order to prevent logging during triggers.
--

CREATE TABLE my_sequences(seq_name      VARCHAR2(50) NOT NULL PRIMARY KEY,
                          current_value NUMBER       NOT NULL);

INSERT INTO my_sequences VALUES('LOCK_SEQ',0);
#foreach($type in $types)
INSERT INTO my_sequences VALUES('SEQ_${type.shortname.toUpperCase()}',0);
#end

CREATE OR REPLACE FUNCTION ome_nextval(p_seq_name   IN VARCHAR2,
                                       p_block_size IN NUMBER DEFAULT 1)
RETURN number AS
PRAGMA autonomous_transaction;
    pl_current_value NUMBER   := null;
BEGIN

   BEGIN
       SELECT current_value
         INTO pl_current_value
         FROM my_sequences
        WHERE UPPER(seq_name) = UPPER(p_seq_name)
        FOR UPDATE OF current_value;

       UPDATE my_sequences
          SET current_value   = current_value + p_block_size
        WHERE UPPER(seq_name) = UPPER(p_seq_name);

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            -- i.e. pass
            pl_current_value := null;
    END;

    COMMIT;

    IF pl_current_value is null THEN
        raise_application_error(-20000, 'Unknown sequence name: ' || p_seq_name, FALSE);
    END IF;
    return pl_current_value+p_block_size;

END ome_nextval;
/


--
-- #1390 : Triggering the addition of an "REINDEX" event on annotation events.
--

CREATE GLOBAL TEMPORARY TABLE current_session (event_id NUMBER(19),
                                               user_id  NUMBER(19),
                                               group_id NUMBER(19))
    ON COMMIT DELETE ROWS;

CREATE OR REPLACE PROCEDURE prepare_session(event_id IN NUMBER,
                                            user_id  IN NUMBER,
                                            group_id IN NUMBER)
IS
BEGIN
    DELETE FROM current_session;
    INSERT INTO current_session VALUES (event_id, user_id, group_id);
END prepare_session;
/

CREATE OR REPLACE FUNCTION current_event
RETURN NUMBER
IS
    eid NUMBER;
    tblChk NUMBER;
BEGIN
    SELECT count(*) INTO tblChk FROM sys.all_tables WHERE table_name = 'CURRENT_SESSION';
    IF NVL(tblChk,0) = 0
    THEN
        RETURN 0;
    END IF;
    SELECT event_id INTO eid FROM current_session;
    RETURN eid;
END current_event;
/

CREATE OR REPLACE FUNCTION current_or_new_event
RETURN NUMBER
IS
    eid NUMBER;
BEGIN
    eid := current_event();
    IF eid = 0 OR eid IS NULL
    THEN
        eid := ome_nextval('seq_event');
        INSERT INTO event (id, permissions, status, time, experimenter,
                           experimentergroup, "session", type)
            VALUES (eid, -52, 'TRIGGERED', SYSDATE, 0, 0, 0, 0);
    END IF;
    RETURN eid;
END current_or_new_event;
/

CREATE GLOBAL TEMPORARY TABLE updated_annotations (entitytype VARCHAR2(255 char),
                                                   entityid   NUMBER(19))
    ON COMMIT DELETE ROWS;

CREATE OR REPLACE TRIGGER annotation_trigger
AFTER UPDATE ON annotation
FOR EACH ROW
DECLARE
    parent_id NUMBER;
    eid       NUMBER;
    cnt       NUMBER;
BEGIN
#foreach($type in $types)
#if(${type.annotated} && !${type.superclass})
    FOR rec IN (SELECT parent FROM ${type.annLinkTableName()} WHERE child = :NEW.id)
    LOOP
        INSERT INTO updated_annotations (entityid, entitytype)
            VALUES (rec.parent, '${type.id}');
    END LOOP;
#end
#end

    SELECT count(*) INTO cnt FROM updated_annotations;
    IF cnt <> 0
    THEN
        eid := current_or_new_event();
        INSERT INTO eventlog (id, action, permissions, entityid, entitytype, event)
            SELECT ome_nextval('seq_eventlog'), 'REINDEX', -52, entityid, entitytype, eid
            FROM updated_annotations;
    END IF;
END annotation_trigger;
/

#foreach($type in $types)
#if(${type.annotated} && !${type.superclass})
CREATE OR REPLACE TRIGGER ${type.annLinkEventTriggerName()}
AFTER UPDATE ON ${type.annLinkTableName()}
FOR EACH ROW
DECLARE
    eid NUMBER;
    nextval NUMBER;
BEGIN
    eid := current_or_new_event();
    nextval := ome_nextval('seq_eventlog');
    INSERT INTO eventlog (id, action, permissions, entityid, entitytype, event)
        VALUES (nextval, 'REINDEX', -52, :NEW.parent, '${type.id}', eid);
END ${type.annLinkEventTriggerName()};
/

-- Delete triggers to go with update triggers (See #9337)
CREATE OR REPLACE TRIGGER ${type.annLinkDeleteTriggerName()}
BEFORE DELETE ON ${type.annLinkTableName()}
FOR EACH ROW
DECLARE
  eid NUMBER;
  nextval NUMBER;
BEGIN
  eid := current_or_new_event();
  nextval := ome_nextval('seq_eventlog');
  INSERT INTO eventlog (id, action, permissions, entityid, entitytype, event)
    VALUES (nextval, 'REINDEX', -52, :OLD.parent, '${type.id}', eid);
END ${type.annLinkDeleteTriggerName()};
/

#end
#end
--
-- END #1390
--




--
-- First, we install a unique constraint so that it is only possible
-- to go from versionA/patchA to versionB/patchB once.
--
alter table dbpatch add constraint unique_dbpatch unique (currentVersion, currentPatch, previousVersion, previousPatch);

--
-- Since this is a table that we will be using in DB-specific ways, we're also going
-- to make working with it a bit simpler.
--
alter table dbpatch modify permissions default -52;
alter table dbpatch modify message default 'Updating';
-- Following Trigger is doing what "DEFAULT ome_nextval('seq_dbpatch');" is doing in PostGres.
CREATE OR REPLACE TRIGGER dbpatch_autonumber
BEFORE INSERT ON dbpatch FOR EACH ROW
BEGIN
    IF :NEW.id IS NULL THEN
	SELECT OME_NEXTVAL('seq_dbpatch') INTO :NEW.id FROM dual;
    END IF;
END;
/

SHOW ERRORS;


--
-- Then, we insert into the patch table the patch (initialization) which we are currently
-- running so that if anything goes wrong, we'll have some record.
--
insert into dbpatch (currentVersion, currentPatch, previousVersion, previousPatch, message)
             values ('@DBVERSION@',  @DBPATCH@,    '@DBVERSION@',   0,             'Initializing');

--
-- Here we will create the root account and the necessary groups
--
insert into experimenter (id,permissions,version,omename,firstname,lastname)
        values (0,0,0,'root','root','root');
insert into experimenter (id,permissions,version,omename,firstname,lastname)
        select ome_nextval('seq_experimenter'),0,0,'guest','Guest','Account' from dual;
insert into node
        (id,permissions,uuid,conn,up,down)
        select 0,-52,'000000000000000000000000000000000000','unkclock_timestampn',SYSDATE,SYSDATE FROM dual;
insert into session_
        (id,permissions,timetoidle,timetolive,started,closed,defaulteventtype,uuid,owner,node)
        select 0,-52,0,0,SYSDATE,SYSDATE,'BOOTSTRAP',0000,0,0 FROM dual;
insert into session_
        (id,permissions,timetoidle,timetolive,started,closed,defaulteventtype,uuid,owner,node)
        select ome_nextval('seq_session'),-52,0,0,SYSDATE,SYSDATE,'PREVIOUSITEMS','1111',0,0 FROM dual;
insert into event (id,permissions,time,status,experimenter,"session") values (0,0,SYSDATE,'BOOTSTRAP',0,0);

--
-- Default group permissions (ticket:1783)
-- * "system" is private, so that administrators do not share by accident
-- * "user" is public by default since its purpose is to share objects (ticket:1794)
-- * "guest" is private by default so that it doesn't show up on any lists,
--    though nothing should be created there.
--
insert into experimentergroup (id,permissions,version,name)
        values (0,-120,0,'system');
insert into experimentergroup (id,permissions,version,name)
        select ome_nextval('seq_experimentergroup'),-52,0,'user' from dual;
insert into experimentergroup (id,permissions,version,name)
        select ome_nextval('seq_experimentergroup'),-120,0,'guest' from dual;

insert into eventtype (id,permissions,value) values
        (0,-52,'Bootstrap');
insert into groupexperimentermap
        (id,permissions,version, parent, child, child_index,owner)
        values
        (0,-52,0,0,0,0,1);
insert into groupexperimentermap
        (id,permissions,version, parent, child, child_index,owner)
        select ome_nextval('seq_groupexperimentermap'),-52,0,1,0,1,0 from dual;
insert into groupexperimentermap
        (id,permissions,version, parent, child, child_index,owner)
        select ome_nextval('seq_groupexperimentermap'),-52,0,2,1,0,0 from dual;

update event set type = 0;
update event set experimentergroup = 0;

alter table event modify type number(20) not null;
alter table event modify experimentergroup number(20) not null;


## ENUMS
#foreach($enum in $types)
#foreach($prop in $enum.properties)
#set($table = ${enum.typeToColumn($enum.id)} )
#if($prop.class.name == "ome.dsl.EntryField")
insert into $table (id,permissions,value)
    select ome_nextval('seq_$table'),-52,'$prop.name' from dual;
#end
#end
#end

-- Adding bit depth to pixelstype (#2724)
update pixelstype set bitsize = 1 where value = 'bit';
update pixelstype set bitsize = 8 where value = 'int8';
update pixelstype set bitsize = 8 where value = 'uint8';
update pixelstype set bitsize = 16 where value = 'int16';
update pixelstype set bitsize = 16 where value = 'uint16';
update pixelstype set bitsize = 32 where value = 'int32';
update pixelstype set bitsize = 32 where value = 'uint16';
update pixelstype set bitsize = 32 where value = 'uint32';
update pixelstype set bitsize = 32 where value = 'float';
update pixelstype set bitsize = 64 where value = 'double';
update pixelstype set bitsize = 64 where value = 'complex';
update pixelstype set bitsize = 128 where value = 'double-complex';
alter table pixelstype modify bitsize number(20) not null;

--
-- Cryptographic functions for specifying UUID
--

CREATE OR REPLACE FUNCTION uuid
   RETURN CHAR
   IS
   v_uuid    CHAR(36) := NULL;
   BEGIN
      SELECT SUBSTR(sys_guid, 1, 8)  ||'-'||
             SUBSTR(sys_guid, 9, 4)  ||'-'||
             SUBSTR(sys_guid, 13, 4) ||'-'||
             SUBSTR(sys_guid, 16, 4) ||'-'||
             SUBSTR(sys_guid, 20, 12)
        INTO v_uuid
        FROM DUAL;

        RETURN v_uuid;
END;
/

CREATE OR REPLACE FUNCTION sys_guid
RETURN RAW
IS
c RAW(16);
BEGIN
   SELECT SYS_GUID()
   INTO c
   FROM sys.dual;
RETURN c;
END;
/

--
-- Configuration table including a UUID uniquely identifying this database.
--
create table configuration ( name varchar2(255) primary key, value CLOB );
insert into configuration values ('omero.db.uuid', uuid);

--
-- ticket:2201 - creating repository data structures
--
alter  table pixels add (path varchar(2048));
alter  table pixels add (name CLOB);
alter  table pixels add (repo varchar(36));
alter  table pixels add (params PARAMS_MAP);
create index pixels_repo_index on pixels (repo);
-- No unique index on (path, repo, name) since it depends on params

alter  table originalfile modify mimetype default 'application/octet-stream';
alter  table originalfile add (repo varchar(36));
alter  table originalfile add (params PARAMS_MAP);
create index originalfile_mime_index on originalfile (mimetype);
create index originalfile_repo_index on originalfile (repo);
create unique index originalfile_repo_path_index on originalfile (repo, path, name);

--
-- end ticket:2201
--

-- Indices. See #1640, #2573, etc.
create unique index namespace_name on namespace (name);
create unique index well_col_row on well (plate, "column", "row");
create index eventlog_entitytype on eventlog(entitytype);
create index eventlog_entityid on eventlog(entityid);
create index eventlog_action on eventlog(action);



create table password ( experimenter_id number primary key REFERENCES experimenter (id), hash char(24), dn CLOB );
insert into password (experimenter_id, hash) values (0,'@ROOTPASS@');
insert into password (experimenter_id, hash) values (1,'');
-- root can now login with omero.rootpass property value
-- and guest can login with any value

-- Here we have finished initializing this database.
update dbpatch set message = 'Database ready.', finished = SYSDATE
  where currentVersion = '@DBVERSION@' and
        currentPatch = @DBPATCH@ and
        previousVersion = '@DBVERSION@' and
        previousPatch = 0;


SPOOL OFF;
EXIT;
